erc721_deposit(string memory _vault, uint256 _erc721_Id, uint256 _maxAmountToBorrow) :
    - le nft provient bien de maiFinance
    - le nft appartiens bien au msg.sender
    - _maxAmountToBorrow doit être > 0
    - _maxAmountToBorrow doit être <= au montant max empruntable
    - la valeur que l'on peut déléguer doit être incrémentée de _maxAmountToBorrow
    - le nft correspond à un vault qui existe sur mai maiFinance
    - le nft correspond à un vault dont le token existe dans notre contrat

erc721_withdraw(string memory _vault, uint256 _erc721_Id, bool withdrawEvenIfBorrowed) :
    - msg.sender est bien le propriétaire du nft _erc721_Id
    - le contrat possède bien le nft _erc721_Id
    - si withdrawEvenIfBorrowed on autorise le retrait même si une partie ou tous les tokens ont été empruntés
    - si withdrawEvenIfBorrowed = false on refuse le retrait si une partie ou tous les tokens ont été empruntés + on renvoie une erreur
    - on retire le nft du mapping isOwner
    - on modifie le mapping has delegated associé au nft _erc721_Id
    - si une partie des tokens (ou tous les tokens) est empruntée et que withdrawEvenIfBorrowed = true on retire la valeur empruntée du mapping borrowed (on annule la dette de l'emprunteur)

approveDelegation(address _borrower, uint _amount, string memory _vault) :
    - msg.sender doit avoir assez de pouvoir de déléguation (ie: borrowedAmount[msg.sender][_vault]-totalDelegated[msg.sender][_vault] >= _amount) 
    - la valeur que _borrower peut emprunter dans _vault est augmentée de _amount
    - _amount peut être null (on revoque les droits d'emprunt)
    - si _amount = 0 et que le borrower a deja emprunté une partie/tous les tokens, on renvoie une erreur contenant le montant deja emprunté

borrow(uint _amount, address _delegator, string memory _vault) :
    - _amount doit être > 0
    - borrowed[_delegator][msg.sender][_vault] - hasdelegated[_delegator][msg.sender][_vault] doit être <= _amount
    - borrowed[_delegator][msg.sender][_vault] doit être augmenté de _amount
    - totalBorrowed[msg.sender][_vault] doit être augmenté de _amount

repayToOurContract(uint _amount, address _delegator, string memory _vault) : 
    - _amount doit être > 0
    - borrowed[_delegator][msg.sender][_vault] doit être >= _amount
    - borrowed[_delegator][msg.sender][_vault] doit être diminué de _amount
    - le contract recoit bien _amount de token correspondants au _vault
    - totalBorrowed[msg.sender][_vault] doit être diminué de _amount (si par hasard, totalBorrowed[msg.sender][_vault] deviens négatif, on le met à 0 et QUE FAIRE DU RESTE ?)

addCollateralToMaiFinance(uint _amount, uint _tokenid, string memory _vault) :
    - le montant empruntable par notre contrat auprès de mai finance doit être augmenté de _amount

addAdmin(address _admin) : 
    - msg.sender doit être un admin
    - ajoute _admin à la liste des admins (mapping admin)

edit_vaultAdress(string memory _tokenName, address _vault)
    - msg.sender doit être un admin
    - _vault doit être une adresse valide
    - _tokenName doit correspondre au nom du token associé au contrat _vault (on peut utiliser la fonction name() du contrat _vault pour comparer)

// FAIRE UNE FCT QUI PERMET AU DETENTEUR DU NFT D'EMPRUNTER PLUS DE TOKENS AUPRES DE MAI FINANCE
// FAIRE UNE FCT QUI PERMET AU DETENTEUR DU NFT DE REMBOURSER DES TOKENS AUPRES DE MAI FINANCE (EN VERIFIANT SI LES TOKENS TRANSFERES DEPUIS NOTRE CONTRAT N'ONT PAS ETE DELEGUES)


